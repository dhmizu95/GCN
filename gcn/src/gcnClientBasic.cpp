/*
 * Group Centric Networking
 *
 * Copyright (C) 2015 Massachusetts Institute of Technology
 * All rights reserved.
 *
 * Authors:
 *           Patricia Deutsch         <patricia.deutsch@ll.mit.edu>
 *           Gregory Kuperman         <gkuperman@ll.mit.edu>
 *           Leonid Veytser           <veytser@ll.mit.edu>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
*/

#include "gcnClientBasic.h"

void usage(const string & sAppName)
{
	cout<<"usage: "<<sAppName <<" [OPTIONS]"<<endl;
	cout<<endl;
	cout<<"options:"<<endl;
	cout<<"  -h, --help               Print this message and exit."<<endl;
	cout<<endl;
	cout<<" REQUIRED options: " << endl;
	cout<<"  -g, --groupid  GID      Group to which this app belongs." <<endl;
	cout<<endl;
	cout<<"  -i, --id   NODEID       Set the node id."<<endl;
	cout<<endl;
	cout<<" OPTIONAL options: " << endl;
	cout<<endl;
	cout<<"  NOTE: Default values will be used if these options are not specified on the command line"<<endl;
	cout<<endl;
	cout<<"  -t, --type  TYPE        Application type. 0 = " << AppTypeStr[0] << "   1 = " << AppTypeStr[1] << "   2 = " << AppTypeStr[2] <<endl;
	cout<<"                          Default is 0 " << AppTypeStr[0] <<endl;
	cout<<endl;
	cout<<"  -l, --loglevel [1-6]    Set initial log level."<<endl;
	cout<<"                               1 = "<< LogLevelStr[1] << "   2 = " << LogLevelStr[2] << "   3 = " << LogLevelStr[3] ;
	cout<<"                               4 = "<< LogLevelStr[4] << "   5 = " << LogLevelStr[5] << "   6 = " << LogLevelStr[6] << "   7 = " << LogLevelStr[7]<< endl;
	cout<<"                           Default is " << LogLevelStr[DEFAULT_LOG_LEVEL] <<endl;
	cout<<endl;
	cout<<"  -v, --datafile  DATAFILE Set the filename for data item logging."<<endl;
	cout<<endl;
	cout<<"  -p, --port PORTNUM       Set the port number to listen to clients. "<<endl;
	cout<<"                           Default is "<<DEFAULT_PORTNUM<<endl;
	cout<<endl;
	cout<<"  -s, --srcttl SRCTTL      Set the source ttl for messages generated by this node. "<<endl;
	cout<<"                           Default is "<<DEFAULT_SRCTTL<<endl;
	cout<<endl;
	cout<<"  -r, --pushrate PUSH_RATE     Set the message rate in seconds for this node to generate DATA messages."<<endl;
	cout<<"                               Default is to generate a message every "<< DEFAULT_PUSH_RATE<< " seconds"<<endl;
	cout<<"                               Use 0 to send no DATA messages"<<endl;
	cout<<endl;
	cout<<"  -b, --msgsize MSG_SIZE       Set the the minimum size of DATA messages to send."<<endl;
	cout<<"                               Default is to generate a message that has a minimum size of 100 bytes"<<endl;
	cout<<endl;
	cout<<"  -a, --annrate ANNOUNCE_RATE  Set the message rate in seconds for this node to generate ANNOUNCE messages."<<endl;
	cout<<"                               Default is to generate a message every "<< DEFAULT_ANNOUNCE_RATE<< " seconds"<<endl;
	cout<<"                               Use -1 to send no ANNOUNCE messages."<<endl;
	cout<<"                               If 0, then App does not send ANNOUNCE but must still get a pull from GCN before it starts sending data (advertise override)."<<endl;
	cout<<"                               If >0, then App sends ANNOUNCE and must get a pull from GCN before it starts sending data."<<endl;
	cout<<endl;
	cout<<"  -k, --ackprobrelay PROB      Set the probability of relay for ACK messages when received at a node that is not the obligatory relay."<<endl;
	cout<<"                               If the value is from 0 to 100, then the value is used as the prob of relay."<<endl;
	cout<<"                               If the number is greater than 100, then the value is used to determine prob of relay"<<endl;
	cout<<"                               based on the number of neighbors as: value/N where N is # neighbors."<< endl;
	cout<<"                               Default value is 0."<< endl;
	cout<<endl;
	cout<<"  -u, --unicast SEND_RESPONSE  Set a flag to indicate whether or not this app should send Unicast DATA messages back to source."<<endl;
	cout<<"                               This option is ONLY supported on non-source nodes."<<endl;
	cout<<"                               Default is 0 which means that the app will NOT send unicast responses "<<endl;
	cout<<"                               Use 1 to send unicast responses back to GID source."<<endl;
	cout<<endl;
	cout<<"  -f, --respFreq SEND_FREQ     Set the frequency for sending unicast responses based on the number of messages received."<<endl;
	cout<<"                               Default is 100 which means that the app will send unicast responses every 100th message received "<<endl;
	cout<<"                               Used only when the node is sending unicast responses (i.e., -u is set to 1)."<<endl;
	cout<<endl;
	cout<<"  -w, --respttl RESP_TTL       Set the src ttl for the unicast responses."<<endl;
	cout<<"                               Default value is the src ttl of the original DATA packet received from the GID soure node. "<<endl;
	cout<<"                               Applies ONLY to non-source nodes and is an optional value."<<endl;
	cout<<endl;
	cout<<"  -x, --resilience RESILIENCE  Resilience value this app should use if it is sending unicast response to GID source."<<endl;
	cout<<"                               Default is 0 which means the app uses its know hop count to the source "<<endl;
	cout<<"                               Use 1 or 2 to increase this value."<<endl;
	cout<<endl;
	cout<<"  -z, --stopcount STOP_COUNT   Set the number of packets to send before stop sending traffic Applies only to sending nodes."<<endl;
	cout<<"                               Default is never stop."<<endl;
	cout<<"                               Traffic will top if either the stopcount is met or the stoptime is met." << endl;
	cout<<endl;
	cout<<"  -y, --stoptime STOP_TIME     Set the time in seconds before stop sending traffic Applies only to sending nodes."<<endl;
	cout<<"                               Default is never stop."<<endl;
	cout<<"                               Traffic will top if either the stopcount is met or the stoptime is met." << endl;
	cout<<endl;
	cout<<"  -d, --dontregeneratettl       Do NOT regenerate TTL for DATA messages and ADVERTISE messages at group nodes"<<endl;
	cout<<"                                Default behavior is to regenerate the TTL based on source TTL at a group node"<<endl;
	cout<<"                                Set by the source node so this value is not relavent for non-source nodes"<<endl;
	cout<<endl;
}


//************************************************************************
gcnClientBasic::gcnClientBasic(io_service * io_serv)
: pIoService(io_serv),
  mSendTimer(*pIoService, Seconds(1)),  
  mMessageCounter(1), 
  mPushRate(DEFAULT_PUSH_RATE),
  mMsgSize(0)
{

}

//************************************************************************
gcnClientBasic::~gcnClientBasic()
{
	
}


//************************************************************************
bool gcnClientBasic::Start(const ClientConfig &config)
{
	pGcnClient.reset(new gcnClient(pIoService));

	mCurrentLogLevel = config.logLevel;
	mNodeId = config.nodeId;

	if ( (config.type == 1) || (config.type == 2) )
	{
		// We are source node
		// Set timer for sending data (PUSH messages)
		mGroupId = config.gid;
		mPushRate = config.pushRate*1000; // convert to milliseconds
		mStopCount = config.stopCount;
		mStopTime = config.stopTime;
		mMsgSize = config.msgSize;
		
		// get time stamp
		TimeDuration currDur = getTime();
		mStartTime = duration_cast<seconds>(currDur).count();

		
		if (mPushRate > 0)
		{
			mSendTimer.async_wait(boost::bind(&gcnClientBasic::OnSendTimeout, this));
			LOG(LOG_FORCE, "scheduling event with start %lfsec and interval %lfmsec", 1.0, mPushRate);
		}
	}

	// init client object;
	function<bool(Data & dataMsg)> handler2 = bind(&gcnClientBasic::processDataMessage, this, std::placeholders::_1);
	if (!pGcnClient->Start(config, handler2))
	{
		LOG(LOG_FORCE, "Failed to connect to server. Client stopped");
		return false;
	}

	return true;
}


//************************************************************************
void gcnClientBasic::Stop(const error_code& ec, int signal_number)
{
	// If we were sending data stop periodic event for sending
	mSendTimer.cancel();
	printf(" ... Send event canceled\n");
	
	pGcnClient->Stop();
	
	pIoService->stop();
	exit(1);
}

//************************************************************************
void gcnClientBasic::Run()
{
	pIoService->run();
}

//************************************************************************
void gcnClientBasic::OnSendTimeout()
{
	// get time stamp
	TimeDuration currDur = getTime();
	int currTime = duration_cast<seconds>(currDur).count();
	
	// Get microseconds timestamp to put into packet
	auto micro = duration_cast<microseconds>(currDur).count();
	
	// Construct payload
	array<char, MAX_BUFFER_SIZE> msgBuffer;
	char* tempMsg = msgBuffer.data();
	sprintf(tempMsg, "%ld", micro);
	//LOG_ASSERT(strlen(tempMsg) == TIMESTAMP_SIZE, "Timestamp in message is %d length but it should be %d", strlen(tempMsg), TIMESTAMP_SIZE);
	sprintf(tempMsg + strlen(tempMsg), " %d src %d ", mMessageCounter, mNodeId);
	
	if (strlen(tempMsg) > mMsgSize)
	{
		LOG(LOG_ERROR, "Size of message sent (%d) EXCEEDS the user specified data size (%d)", strlen(tempMsg), mMsgSize);
	}
	
	while (strlen(tempMsg) < mMsgSize) 
	{
		sprintf(tempMsg + strlen(tempMsg), "x");
	}
	
	// only increment message counter if we send successfully
	if (pGcnClient->sendMessage(mGroupId, tempMsg))
		mMessageCounter++;

	// reschedule the periodic event
	if ((mPushRate > 0) && !(mStopCount && (mMessageCounter > mStopCount))  && ((currTime - mStartTime) < mStopTime) )
	{
		mSendTimer.expires_at(mSendTimer.expires_at() + Milliseconds(mPushRate));
		mSendTimer.async_wait(boost::bind(&gcnClientBasic::OnSendTimeout, this));
	}
	else
	{
		LOG(LOG_FORCE, "No longer scheduling packet sends. mMessageCounter: %d  mStopCount %d  mStopTime %d", mMessageCounter, mStopCount, mStopTime);
	}
}

//************************************************************************
// function to process received messages
bool gcnClientBasic::processDataMessage(Data & dataMsg)
{
	double eteDelay = 0.0;
	uint32_t pktNum;
	
	uint32_t srcNode = dataMsg.srcnode();
	
	// Get timestamp from message
	
	// Split the data into a set of strings and manipulate below
	string data = dataMsg.data();
		
	std::vector<std::string> strs;
	std::vector<string>::iterator iter;
	boost::split(strs, data, boost::is_any_of(" "), token_compress_on);
	
	iter = strs.begin(); 
	
	// If this is NOT unicast, then get the timestamp, pkt # and src node
	// non-unicast look like this:
	//            1262304015000000 10 src 1 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
	if ( !(dataMsg.has_uheader()) )
	{
		
		uint64_t sendTime = atol((*iter).c_str());
		
		++iter;
		pktNum = atoi((*iter).c_str());
		
		++iter;
		++iter;
		uint32_t srcNode2 = atoi((*iter).c_str());
		
		if (srcNode != srcNode2)
			LOG(LOG_ERROR,"src node in payload %d does not match srcnode in protobuf %d", srcNode2, srcNode);
		
		// get current time stamp and calculate ete delay
		TimeDuration currDur = getTime();
		auto micro = duration_cast<microseconds>(currDur).count();
		eteDelay = ((double)(micro - sendTime))/1000000.0;
	}
	else
	{
		// This is unicast packet which looks like this:
		//            Response 10 to node 1 for GID 1001
		++iter;
		pktNum = atoi((*iter).c_str());
	}

	// insert into set
	std::pair<std::set<DataKey>::iterator,bool> ret;
	ret = mDataSeenSet.insert(DataKey(dataMsg.gid(),srcNode,pktNum));
	
	if (ret.second == false)
	{
		LOG(LOG_ERROR, "Received DUPLICATE packet. GID %d. src node %d  Pkt num %d  ete delay %0.6lf", dataMsg.gid(), srcNode, pktNum, eteDelay);
	}
	else if (eteDelay > 120.0)
	{
		LOG(LOG_ERROR, "ETE delay exceeds 120 seconds. GID %d. src node %d  Pkt num %d  ete delay %0.6lf", dataMsg.gid(), srcNode, pktNum, eteDelay);
	}
	
	LOG(LOG_DEBUG, "Received DATA for GID %d. src node %d  Pkt num %d  ete delay %0.6lf. %s", dataMsg.gid(), srcNode, pktNum, eteDelay, data.c_str());
	
	return(ret.second);
}

//************************************************************************
// main to accept command line and instantiate the GCN client

int main(int argc, char* argv[])
{
	// Parse command line options
	vector<option> options =
	{
		{"help",    0, nullptr, 'h'},
		{"groupid", 1, nullptr, 'g'},
		{"type",    1, nullptr, 't'},
		{"loglevel", 1, nullptr, 'l'},
		{"datafile", 1, nullptr, 'v'},
		{"id",      1, nullptr, 'i'},
		{"port",    1, nullptr, 'p'},
		{"srcttl",  1, nullptr, 's'},
		{"pushrate",1, nullptr, 'r'},
		{"msgsize", 1, nullptr, 'b'},
		{"annrate", 1, nullptr, 'a'},
		{"ackprobrelay", 1, nullptr, 'k'},
		{"unicast",1, nullptr, 'u'},
		{"respFreq",1, nullptr, 'f'},
		{"respttl", 1, nullptr, 'w'},
		{"resilience",1, nullptr, 'x'},
		{"stopcount",1, nullptr, 'z'},
		{"stoptime",1, nullptr, 'y'},
		{"dontregeneratettl",   0, nullptr, 'd'},
		{0,         0, nullptr,  0 }
	};

	string sOptString{"hg:t:l:v:i:p:s:r:b:a:k:u:f:w:x:z:y:d"};

	int iOption{};
	int iOptionIndex{};
	int tempRes;
	
	// Init variables with default values
	ClientConfig config;
	config.gid = 0;
	config.type = 0;
	config.logLevel = DEFAULT_LOG_LEVEL;
	config.nodeId = 0;
	config.port = DEFAULT_PORTNUM;
	config.srcttl = DEFAULT_SRCTTL;
	config.announceRate = DEFAULT_ANNOUNCE_RATE;
	config.ackProbRelay = 0;
	config.pushRate = DEFAULT_PUSH_RATE;
	config.stopCount = 0;
	config.stopTime = INT_MAX;
	config.msgSize = 100;
	config.sendResponse = 0;
	config.sendRespFreq = 100;
	config.respTtl = 0;
	config.resilience = LOW;
	config.regenerateTtl = true;
	config.dataFile = "";

	while((iOption = getopt_long(argc,argv,sOptString.c_str(), &options[0], &iOptionIndex)) != -1)
	{
		switch(iOption)
		{
		case 'h':
			usage(argv[0]);
			return 0;
			break;
		case 'g':
			config.gid = atoi(optarg);
			break;
		case 't':
			config.type = atoi(optarg);
			break;
		case 'l':
			config.logLevel = (LogLevel)atoi(optarg);
			break;
		case 'v':
			config.dataFile = optarg;
			break;
		case 'i':
			config.nodeId = atoi(optarg);
			break;
		case 'p':
			config.port = atoi(optarg);
			break;
		case 's':
			config.srcttl = atoi(optarg);
			break;
		case 'r':
			config.pushRate = atof(optarg);
			break;
		case 'z':
			config.stopCount = atoi(optarg);
			break;
		case 'y':
			config.stopTime = atoi(optarg);
			break;
		case 'b':
			config.msgSize = atof(optarg);
			break;
		case 'a':
			config.announceRate = atoi(optarg);
			break;
		case 'k':
			config.ackProbRelay = atoi(optarg);
			break;
		case 'u':
			config.sendResponse = atoi(optarg);
			break;
		case 'f':
			config.sendRespFreq = atoi(optarg);
			break;
		case 'w':
			config.respTtl = atoi(optarg);
			break;
		case 'x':
			tempRes = atoi(optarg);
			if (UnicastResilience_IsValid(tempRes))
			{
				config.resilience = (UnicastResilience) tempRes;
			}
			else
			{
				cout <<"\n************** ERROR: Invalid resilience: "<< config.resilience <<" **************"<<endl;
				cout <<"\n************** resilience must be 0, 1 or 2                         **************\n"<<endl;
				usage(argv[0]);
				return 1;
			}
			break;
		case 'd':
			config.regenerateTtl = false;
			break;
		default:
			usage(argv[0]);
			exit (1); 
		}
	}

	// Check for required variables 
	if ( config.gid == 0 )
	{
		cout << "\n************** ERROR: Must enter a group id **************\n" << endl;
		usage(argv[0]);
		exit (1);
	} 
	
	if ( config.nodeId == 0 )
	{
		cout << "\n************** ERROR: Must enter a node id **************\n" << endl;
		usage(argv[0]);
		exit (1);
	}  
	
	// Check that type is valid
	if ( (config.type != 0) && (config.type != 1) && (config.type != 2) )
	{
		cout << "\n************** ERROR: Type must be 0, 1 or 2 **************\n" << endl;
		usage(argv[0]);
		return 1;
	}  
	
	// Make sure log level is valid
	if (config.logLevel <= LOG_INVALID || config.logLevel >= LOG_INVALID_MAX)
	{
		printf("\n************** ERROR: Invalid log level: %db**************\n", config.logLevel);
		usage(argv[0]);
		return 1;
	}

	// This client does NOT support bi-drectional unicast!!
	if ( (config.type > 0) && (config.sendResponse != 0) )
	{
		config.sendResponse = 0;
		std::cout << "\n************** ERROR: Reset Send Response to false for node id " << config.nodeId << " **************\n";
		std::cout << "************** This client does NOT support the source node sending Unicast.  **************\n";
		std::cout << "************** This client only supports non-source nodes sending Unicast.    **************\n\n";
	}

	// We successfully read the command line 
	// instantiate our app
	io_service mIoService;
	gcnClientBasic mApp(&mIoService);
	
	if (!(mApp.Start(config)) )
	{
		boost::system::error_code ec;
		mApp.Stop(ec,0);
	}
	
	boost::asio::signal_set signals(mIoService, SIGINT, SIGTERM);
	signals.async_wait(boost::bind(&gcnClientBasic::Stop, &mApp, _1, _2));

	mApp.Run();
	

	return 0;
}
	



